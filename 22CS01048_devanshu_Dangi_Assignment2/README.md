# Lexical Analyzer for Branching Statements

## Project Overview
This C++ program implements a simple lexical analyzer (lexer) for a subset of branching statements (e.g., `if-then-else`). It reads source code from `input.txt`, tokenizes it according to the specified grammar and token patterns, and writes the resulting sequence of tokens to `output.txt`.

## Supported Grammar
```
stmt → if expr then stmt
     | if expr then stmt else stmt
     | ε

expr → term relop term
     | term

term → id
     | number
```

## Token Patterns
| Token    | Pattern                                              |
|----------|------------------------------------------------------|
| digit    | `[0-9]`                                              |
| digits   | `digit+`                                             |
| number   | `digits ('.' digits)? (E[+-]?digits)?`               |
| letter   | `[A-Za-z]`                                           |
| id       | `letter (letter \| digit)*`                         |
| if       | `if`                                                 |
| then     | `then`                                               |
| else     | `else`                                               |
| relop    | `< \| \> \| <= \| >= \| = \| <>`                     |

## File Structure
```
├── input.txt      # Contains the source statement(s) to tokenize
├── output.txt     # Generated by the program: one token per line
└── lexer.cpp      # C++ source file implementing the lexer
```

## Compilation Instructions
Make sure you have a C++ compiler (e.g., `g++`) installed.

```bash
g++ -std=c++11 -o lexer lexer.cpp
```

## Usage
1. Place your input statements in `input.txt`.  
2. Run the compiled lexer:
   ```bash
   ./lexer
   ```  
3. Inspect the token list in `output.txt`.

## Example
**input.txt**:
```
if input<10 then output1=100 else output2>=100
```

**output.txt**:
```
(if, input)
(relop, <)
(number, 10)
(then, then)
(id, output1)
(relop, =)
(number, 100)
(else, else)
(id, output2)
(relop, >=)
(number, 100)
```

## Extension Ideas
- Support floating-point numbers with exponential notation.
- Add other keywords and operators (e.g., `while`, `for`, arithmetic operators).
- Implement a full parser (e.g., using recursive‐descent) based on the grammar.
